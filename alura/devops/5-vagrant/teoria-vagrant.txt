Nosso ambiente de trabalho: "D:\ambiente_dev"

Throubleshooting:

- Caso com o comando comando "sudo apt-get update" esteja aparecendo o erro "Temporary failure resolving 'archive.ubuntu.com" use o comando:
    "echo "nameserver 8.8.8.8" | sudo tee /etc/resolv.conf > /dev/null"

- Caso precisemos editar a sources.list =  $ sudo nano /etc/apt/sources.list

- Podemos receber alertas de configurações identicas quando estivermos subindo máquinas virtuais, isso pode estar acontecendo porque modificamos o arquivo "VagrantFile" 
    para criar novas máquinas virtuais mas não destruímos as máquinas antigas.

- Se for criar máquinas apenas com funções específicas, cuidado para não deixar configurações para a máquina default que estão sendo usadas para outras máquinas como IP's e 
    portas.

- Se tiver problemas com o erro "No module named 'distutils.spawn'" ao utilizar o python ou rodar um playbook.yml do ansible, basta instalar este pacote: $ apt-get install 
    python3-distutils

- Se este erro estiver acontecendo:

    A VirtualBox machine with the name 'ubuntu_bionic64_phpweb' already exists.
    Please use another name or delete the machine with the existing
    name, and try again.

    Pode ser porque outra box está tentando atribuir o mesmo nome no Hypervisor.
    Este problema não ocorre quando executamos o comando $ vagrant up com o mesmo box, mesmo ele já estando criado, porque automaticamente o Vagrant verifica, ve que é o mesmo id 
    e box que já estavam usando aquele nome e provisiona só o que falta. No caso de ser box diferente ele tem que avisar pois considera um erro no VagrantFile.



Aula 01 - A primeira máquina virtual -------

	
	Numa empresa muitas vezes precisamos de diversos ambientes diferentes e ter muitos programas em um só sistema operacional o torna "sujo" mais lento
	
	Ter várias máquinas virtuais facilita a manutenção e configuração alem de todo o hardware estar todo disponivel para todos os projetos ao mesmo tempo, fazendo assim que 
    ele não seja subutilizado nem superutilizado.
	
	É preferível que as aplicações rodem nos mesmos ambientes de suas produções.
	
	Uma opção seria ter uma máquina, como servidor, para cada projeto. Porém, isso tornaria o custo altíssimo para a empresa.
	
	Por isso a opção mais viável é a vitualização.
	
	O Vagrant é o leitor e controlador por linha de comando do Hypervisor (Hyper-V, Virtualbox, VMware, vSphere, Parallels), e o Hypervisor (Também conhecido como monitor) 
    emula o hardware do computador, é aquela camada que fica entre o Sistema Operacional do hardware servidor e os outros sistemas operacionais virtualizados, ou seja, ele 
    criar as máquinas virtuais e permite que estas máquinas utilizem virtualmente os recursos do Hardware.
	
		Obs: O Vagrant não pode funcionar sozinho por isso ele precisa de um destes provedores.
	
	Existem dois tipos de Hypervisor:
	
		Tipo 1: São chamados de "bare metal", pois são executados diretamente no hardware do host. Exemplos: Hyper-V e vSphere, mas existem outros.
		
		Tipo 2: Rodam como uma aplicação em cima do sistema operacional. Exemplos: VirtualBox e VMware, mas existem outros.
	
	Neste curso utilizaremos o Virtualbox como hypervisor.
	
	O Vagrant, através de arquivo de texto consegue definir quais ferramentas e metodologias para que o projeto funcione. Ou seja, através dele definimos a infraestrura como 
    código. 
	

	Comandos e Teoria:

        Obs: Não foi colocado na época do curso, mas é necessário, obviamente, baixar e instalar o Vagrant.
        
        Obs2: Caso não queiramos iniciar uma máquina virtual ubuntu 64 bits ($ vagrant init hashicorp/bionic64), podemos apenas utilizar o comando $ vagrant init no diretório 
                que queremos trabalhar para aparecer somente o arquivo base da máquina virtual.

        Obs3: Precisamos definir qual é a imagem que iremos utilizar em "config.vm.box = "base"", porque se não, ocorrerá a saída abaixo:

            Bringing machine 'default' up with 'virtualbox' provider...
            ==> default: Box 'base' could not be found. Attempting to find and install...
                default: Box Provider: virtualbox
                default: Box Version: >= 0
            ==> default: Box file was not detected as metadata. Adding it directly...
            ==> default: Adding box 'base' (v0) for provider: virtualbox
                default: Downloading: base
                default:
            An error occurred while downloading the remote file. The error
            message, if any, is reproduced below. Please fix this error and try
            again.

            Couldn't open file D:/vagrantVMs/base
	
		$ mkdir vagrant_getting_started (Nós utilizamos "mkdir ambiente_dev" na unidade D:\)
		
		$ cd vagrant_getting_started (Entramos no diretório com cd ambiente_dev)
		
		$ vagrant init hashicorp/bionic64 (Hashicorp é a empresa por traz do Vagrant, Packer, Terraform etc) (bionic64 é a versão do box, a cada versão mais nova ele pode rodar 
        máquinas virtuais com S.O's mais atualizados). Este comando cria o arquivo VagrantFile com informações de recursos e configurações da máquina virtual que o Virtualbox irá 
        rodar.
		
			Obs: bionic64, utilizado no momento deste curso, aceita o S.O standard ubuntu 18.04 LTS.
					Este é um pacote que contém as informações necessárias para rodar uma máquina virtual.
					Praticamente é um pacote básico, a grosso modo, está substituindo aquela imagem pronta do Windows ou Linux que instalavamos no Virtualbox para servidores que 
                    precisavam de outro ambiente de trabalho. Porém lá, instalavamos todos os programas que eram utilizados para trabalhar sem o intuito de servirem como 
                    servidores, mas sim, apenas mais uma máquina para o dia a dia.
		
		$ vagrant up (Para subir a máquina virtual com o pacote básico já definido no arquivo VagrantFile).
		
		$ vagrant halt = Para a máquina virtual.
		
		$ vagrant version = Mostra a versão do Vagrant que estamos usando.
		
		$ vagrant status = Para verificar o status da nossa máquina virtual.
		
		Em resumo: Basicamente conhecemos o gerenciador de Hypervisor que é o Vagrant. Criamos um arquivo VagrantFile através do comando "vagrant init hashicorp/bionic64". 
        E depois através do comando "vagrant up" ele baixou o pacote básico definido no arquivo criado para rodarmos uma máquina virtual do Virtualbox.
		
		Após estes passos podemos abrir o programa do Virtualbox e verificar que a nossa máquina virtual foi criada e está rodando.
		
		Precisamos nos conectar a máquina Linux agora utilizando o protocolo SSH (Secure SHell) que permite que acessemos virtualmente o servidor como se estivessemos em um 
        terminal. Basicamente, um computador controlando outro computador. É um protocolo que faz um computador conversar com outro através de criptografia.
		
		Para que possamos nos conectar realizamos o seguinte comando:
		
		$ vagrant ssh
		
			Se estivermos no Windows podemos ter alguns problemas:
			
			1 - Por não ter o aplicativo "Cliente OpenSSH".
			
				Se for este o caso podemos instalar o pacote "Git" que pode ser baixado no https://gitforwindows.org/
				Este pacote já traz incluso o protocolo SSH utilizando o terminal do Git Bash.
				
				Executamos o Git bash à partir do diretorio de trabalho e executamos o comando "vagrant ssh" para ver se agora funciona.
				
			Se ainda assim não funcionar utilizaremos a forma mais tradicional de estabelecer uma conexão SSH a partir do Windows com a ferramenta PuTTY.
			
			$ vagrant ssh-config = Nos mostra as configurações do protocolo SSH.

			$ ssh -p 2222 vagrant@127.0.0.1 = Estes dados são a porta padrão (2222) alterada pelo Vagrant e o hostname (vagrant@127.0.0.1).
			
				Por padrão normalmente o usuário e a senha serão: vagrant
				
			Após instalar o PuTTY, estes dados servirão para configurá-lo.
			
				IP Address: 127.0.0.1
				Port: 2222
				
				Após isso, clicar no botão "Open".
				
				 Obs: Usuário e senha são os mesmos citados acima.
				 
				Obs: Após o comando vagrant ssh-config a informação de que não estamos usando autenticação de senha pode ser exibida, isto porque a conexão SSH oferece suporte à 
                várias formas de autenticação. A principal delas é a chave pública ou privada, a qual é apresentada na linha "IdentityFile" criada automaticamente.
					
			Se for o caso de utilizar chaves, temos que abrir o programa PuTTYgem (Que veio junto com o pacote do programa PuTTY) e na caixa de dialogo "PuTTY Key Generator" 
            carregar a chave pública/privada clicando no botão "Generate" e indo na pasta "ambiente_dev>.vagrant>machines>default>virtualbox, escolhendo a opção:
            "Todos os arquivos(.)" e selecionando o arquivo "private_key" e clicando em abrir.
				
				Obs: Este caminho não é padrão.
			
			Na janela clicar em "Save private key", confirme a pergunta feita.
			
			Salve a chave dentro do diretório "ambiente_dev" como "chave-precise" e feche a ferramenta PuTTYgem.
			
			Abra novamente o aplicativo PuTTY e confirme se os dados foram carregados automaticamente.
			
			Na lista de categorias, vá no item "SSH > Auth" para definir a nova chave "chave-precise" (Ou aquele com o nome que tivermos criado) Salve as alterações na sessão 
            principal e clique em "Open".
			
			Pode aparecer uma mensagem de alerta informando que houve mudança de chave e a conexão com outro sistema, se aparecer, somente clique em "Sim" para prosseguir e feche 
            a sessão.
			
			
			Nesta aula, aprendemos que:

				 - VirtualBox, VMware, Hyper-V, entre outros, são Hypervisors
				 - Um Hypervisor emula o hardware do computador para criar e executar máquinas virtuais
				 - O Vagrant é uma ferramenta que controla o Hypervisor a partir de um arquivo simples, o Vagranfile
				 - O Vagrantfile define detalhes da máquina virtual, como o sistema operacional, a rede, software utilizado, etc
				 - O comando vagrant init <box> cria um Vagrantfile
				 - A box é baixada da internet e possui a imagem do sistema operacional, entre outras configurações
				 - Para inicializar e rodar a VM com Vagrant, usa-se o comando: vagrant up
				 - O comando vagrant status mostra detalhes sobre o status da máquina virtual
				 - Para se conectar com a máquina virtual, usamos a ferramenta SSH
		
				
	
	Questões:
	
	1 - Quais das ferramentas abaixo são consideradas um Hypervisor?

	Selecione 2 alternativas
	
	R1: VMware 
	
	Alternativa correta! VMware é um Hypervisor! No entanto, nesse curso, usaremos o VirtualBox.

	R2: VirtualBox

    Alternativa correta! Inclusive, a VirtualBox será o Hypervisor que usaremos durante o curso.
	
	
	2 - Quais são as vantagens de usar uma máquina virtual?

	Selecione 2 alternativas
	
	R1: Menos gastos com infraestrutura
	
	Alternativa correta! O mesmo computador (mesmo hardware) pode rodar vários sistemas e ambientes ao mesmo tempo.

	R2: Mais agilidade na criação de ambiente
	
	Alternativa correta! Como ainda veremos, será fácil e rápido criar e rodar um ambiente inteiro de desenvolvimento.
	
	
	3 - Qual é o papel do Vagrantfile?

	Selecione uma alternativa
	
	Conter todos as configurações da máquina virtual

	Alternativa correta! É um belo exemplo de Infraestrutura como código. No Vagrantfile, vamos definir o sistema operacional, a rede, memória, entre outras configurações.
	
	
	4 - Você já viu o comando vagrant up durante a aula. O que ele faz?
	
	Selecione 2 alternativas
	
	R1: Cria a máquina virtual
	Alternativa correta! Correto, se a máquina virtual não foi criada ainda, o comando vai criar. Criar significa baixar e importar a box.
	
	R2: Configura a máquina virtual
	Alternativa correta! Além de criar, também aplica as configurações na máquina virtual.
	
	
	
Aula 02 - Configuração da rede -------

	Comandos e teoria:
	
		$ cat Vagranfile = Podemos ver o conteúdo do nosso arquivo de configuração de máquina virtual (Obviamente temos que estar dentro do diretório do arquivo).
		
		Relembrando: Parar uma máquina virtual, "$ vagrant halt", para verificar "$ vagrant status".
		
		Caso queiramos criar o arquivo da máquina virtual na mão (VagrantFile) podemos verificar como é o código no próprio site do Vagrant Cloud:
        (https://app.vagrantup.com/ubuntu).
		
		Código de exemplo de uma máquina virtual Ubuntu LTS 64bits
		
			Vagrant.configure("2") do |config|
				config.vm.box = "ubuntu/bionic64"
			end
		
		TRABALHANDO COM A MÁQUINA VIRTUAL
		
			Instalando o Nginx:
			
			Já conectados com a máquina virtual ($ vagrant ssh) faremos atualização da lista de pacotes...
			
			$ sudo apt-get update (Se ocorrer algum problema temos a resolução de problema no ínicio deste arquivo)
			
			$ sudo apt-get install -y nginx = Instala o programa Nginx (-y para dar sim automaticamente em todas as opções que forem aparecendo durante a instalação).
			
			$ netstat -lntp = Para confirmar e ver o número do processo.
			
			$ curl http://localhost/ = Para receber em HTML as informações.
			
			Na documentação do Vagrant (docs - Fowarded Ports) verificamos que podemos usar uma porta específica em Windows o qual recebe a requisição e acessa a máquina virtual 
            automaticamente através do processo de Port Fowarding na rede.
		
			A linha fornecida na página acima deve ser adicionada ao arquivo VagrantFile (De preferência embaixo do comentário correto, se é que o seu arquivo foi criado 
            automaticamente a partir do comando "$ vagrant init").
			
			Exemplo: 
			
				Vagrant.configure("2") do |config|
					config.vm.network "forwarded_port", guest: 80, host:8080 (Aqui podemos trocar o host por 8089 de acordo com o curso)
				end
			
			Para que as configurações tenham efeito devemos parar e iniciar a máquina virtual novamente ("$ vagrant halt" e "$ vagrant up") fora da máquina virtual, obviamente.
			
			Se quisermos conferir que a configuração deu certo, basta abrirmos o navegador e digitarmos http://locahost:8089/
			
			Se clicarmos com o botão direito e pedirmos para exibir o código fonte desta páginal html veremos o mesmo código exibido quando executamos o comando: 
            "$ curl http://localhost/" dentro da máquina virtual.
			
			Isto serve para configurar qualquer porta para qualquer aplicação, como um banco de dados.
			Fazemos isso informando a porta do programa e a porta do Windows que irá utilizar para rodar a aplicação.

		    $ vagrant reload = Reinicia e inicia novamente a máquina virtual automaticamente.
		        Obs: As vezes este comando não funciona mesmo, é normal, mas temos que procurar soluções extras pra isso.
		            Mais a frente este problema será tratado.

		    O ideal sempre é que a máquina virtual tenha IP já configurado no código para que sua identificação seja utilizada em outros aplicativos.

		    Como visto antes, na documentação do Vagrant podemos encontrar como configurar cada parâmetro.
		    Vemos na parte "Static IP" em "Network > Private Network", como deixar estático o IP da nossa máquina virtual, na cara de pau, copiamos o código para o VagrantFile.

                Ex.:
		          config.vm.network "private_network", ip: "192.168.50.4"
                  end

            Com o comando "ifconfig" (Interface Config) podemos verificar a existencia de 2 adaptadores, dois deles configurados por nós no arquivo VagrantFile.
                Adapter 1: Configurado, acessa a rede, é a base de SSH.
                Adapter 2: É resultado da configuração que acabamos de implementar (Do exemplo acima).

            Ou seja, conseguimos mudar o S.O e podemos verificar com o comando "ipconfig", assim verificamos as duas interfaces.
                Obs: Não podemos confundir estas com os adaptadores da máquina virtual mostrados anteriormente.

            O primeiro "VirtualBox Host-Only Network" foi criado pelo VirtualBox para definir a rede da MV, e possui uma mascara relacionada com os números do IP da configuração 
            retirada da documentação.

            Podemos abrir outro prompt NO WINDOWS (Fora da máquina virtual) e utilizarmos o comando "ping" para 192.168.50.4 para que vejamos a máquina virtual responder ao envio
            de pacotes.

            Se utilizarmos agora este IP no navegador acessaremos a máquina virtual e o servidor web Nginx ao mesmo tempo que usamos o Port Forwarding com "localhost:8089" na aba 
            anterior.

	        Também podemos verificar os dois adaptadores que foram criados para a máquina virtual acessando a interface "Oracle VM VirtualBox" (Hypervisor) e clicando na máquina 
            virtual que estamos utilizando > Rede.

	        Podemos verificar se as informações batem com as informações exibidas com o comando "ipconfig" no prompt do windows (Mac Address é uma delas).

            Podemos verificar também os adaptadores de rede criados pela VirtualBox nas configurações de rede do Windows.

            Os três tipos de Network-Adapter:

                Bridge: Permite que a máquina virtual participe na rede pública (empresarial).

                NAT (Network Address Translation (Calculo feito com o IP do computador e o mac address)): Usado no "forwarded_port".

                Host-only: "private_network", para comunicação com o hospedeiro apenas.

        CONFIGURANDO DHCP

            Para configurarmos dhcp é bem similar a configuração de IP estático, basta mudarmos a linha:

                config.vm.network "private_network", ip: "192.168.50.4"

            Para:

                config.vm.network "private_network", type: "dhcp"
                    (Encontrado também na parte de documentação do vagrant)

            Obs: O ideal é que para que façamos certas alterações na máquina virtual, destruamos ela antes.
                Não precisamos nos preocupar com a destruição de máquinas virtuais pois nosso arquivo VagrantFile vai continuar existindo o que cria a máquina virtual com as 
                mesmas configurações em pouco tempo com o comando "vagrant up". É importante lembrar sempre que este arquivo representa nossa infraestrutura da máquina virtual 
                como código, a reprodução do ambiente é facilitada.

                O comando para destruirmos a máquina virtual é:

                    $ vagrant destroy (Dentro da pasta onde se encontra nossa máquina virtual).
                        (Podemos verificar sua destruição na interface do programa VirtualBox)

            Após as alterações podemos realizar o comando "vagrant up" mais uma vez para que possamos subir nossa máquina virtual com as mesma configurações, porém agora com IP 
            dinâmico.
                (Podemos novamente verificar no VirtualBox que a nosa máquina foi recriada)
                (Normalmente são solicitadas confirmações do programa VirtualBox no computador, responda sim sempre)

            Podemos verificar que as configurações na guia "Host Network Manager" foram alteradas para DHCP

            O VirtualBox possui um servidor DHCP interno que é criado após estes processos que realizamos.

            Como destruímos a máquina anterior não temos o servidor Web Nginx instalado, por isso devemos realizar o comando:

                $ sudo apt-get update && sudo apt-get install -y nginx

            Observamos assim que o Vagrant por si só, não constrói toda a infraestrutura como código. Por isso é necessário a utilização para realizarmos por completo o que 
            chamamos de provisionamento.

            $ netstat -tlnp = Para verificarmos o funcionamento do Nginx pela porta 80.

            No caso de múltiplas máquinas virtuais, fez sentido que o VirtualBox administrasse os IP's delas. Mas em uma situação de empresa com vários computadores, nossas 
            configurações permitem o acesso somente pelo host do Windows que usamos.

            Para utilizarmos a rede como pública devemos mudar a parte do código onde está:

                config.vm.network "private_network", ip: "192.168.50.4"

                por

                config.vm.network "public_network"

            Caso queiramos utilizar um IP estático:

                config.vm.network "private_network", ip: "IP desejado"

                Obs: No caso até o terceiro grupo o ip deve ser o mesmo da sua máquina física.

            Podemos verificar na inteface do VirtualBox, na nossa máquina virtual bionic64, nas configurações de rede que a placa está em modo bridge. Para que outros computadores 
            possam acessá-la.

            Isto nos possibilita instalar um banco de dados como o Oracle por exemplo de modo a ser acessado pelos desenvolvedores usando os computadores conectados à chave públic.

            Configuração do VagrantFile desta aula sem comentários:

                Vagrant.configure("2") do |config|
                  config.vm.box = "ubuntu/bionic64"
                  config.vm.network "forwarded_port", guest: 80, host: 8089
                  config.vm.network "public_network", ip: "192.168.1.24"
                end

            Explicando melhor o Port Forwarding:

            Port forwarding, ou, em Português, redirecionamento de portas, é o ato de direcionar uma porta da rede (network port) de um nó de rede para outro. Esta técnica pode 
            permitir que um usuário alcance uma porta em um endereço de IP privado (como o de uma LAN) mesmo estando fora dessa rede, através de um roteador com NAT habilitado. 
            Desta forma é possível disponibilizar na rede pública serviços internos, minimizando as probabilidades de compromisso das máquinas internas.

                guest: 80 and host: 8089

                (Guest: Porta da Aplicação, Host: Porta do micro livre para acesso à aplicação)

                by: Wikipedia

    Nesta aula, aprendemos que:

           - Existem 3 formas para configurar a rede:
           - Forwarded Port
           - Private Network
           - Public Network
           - Na configuração Forwarded Port, mapeamos uma porta do host para o guest, por exemplo:
                 config.vm.network "forwarded_port", guest: 80, host: 8089.
           - Na Private Network (static ou dhcp) é usado um endereço privado que não é acessível na sua rede pública (por exemplo, a rede empresarial).
           - Na Public Network (static ou dhcp), usamos um endereço que faz parte da sua rede pública (por exemplo, da rede empresarial) (Por isso o IP tem que ser válido na rede).
           - Com o comando vagrant halt podemos parar a execução da máquina virtual.
           - O comando vagrant reload recarrega a configuração da máquina virtual.

	Questões:
	
	
		1 - Na configuração forwarded_port, usamos configurações guest e host, como no exemplo abaixo:

		config.vm.network "forwarded_port", guest: 80, host: 8088
		O que é guest e host?

		Selecione uma alternativa
		
		R: O guest é a máquina virtual, host é o sistema que roda o provider/hypervisor
		
		Alternativa correta! O host é o hospedeiro (o sistema que permite o guest (convidado) a rodar). O guest é a máquina virtual.


		2 - Veja a configuração abaixo:

        config.vm.network "public_network", ip: "192.168.1.17"
        Usando o VirtualBox como provedor, qual será o Network-Adapter usado?

        Selecione uma alternativa

        R: Bridge

        Alternativa correta! Bridge permite que a máquina virtual participe na rede "pública" (empresarial).


Aula 03 - Lidando com o SSH -------

    Comandos e teoria:

        Já vimos que uma das vantagens de se ter máquina virtual que comportem banco de dados e outras aplicações através do Vagrant é ter nosso S.O limpo, facilitando recriação 
        e exclusão.

        Vimos também como disponibiliza-la em uma rede empresarial através de uma Public Network para uso coletivo. Desta forma é importante estabelecer este acesso remotamente.

        $ vagrant ssh-config = Para ver as configurações.

        $ ssh vagrant@"IP da máquina virtual" = Para testarmos a conexão, pois será desta forma que outros micros acessarão remotamente (IP fixo de preferência).

       Se tentarmos de outro computador uma mensagem de erro é apresentada porque o SSH automaticamente guarda a identificação das máquinas usadas para nos conectarmos em um 
       arquivo chamado "known_hosts".

       $ cat c:\users\nesso\.ssh\known_hosts = Para ler o arquivo (Repare que o arquivo guarda o IP e uma identificação específica).

            Obs: Geralmente, o sistema nos pergunta se queremos adicioná-la ao documento e respondemos positivamente quando nos conectamos pela primeira vez.

       Nossa ID mudou pois recriamos a máquina através do Vagrant, sendo necessário apagar o arquivo "known_hosts".

            $ rm c:\users\nesso\.ssh\known_hosts

       Se foi o caso de não ter conseguido se conectar a primeira e vez e ter apagado o arquivo, lembre-se de executar novamente o comando:

            $ ssh vagrant@"IP da máquina virtual" (Confirme positivamente a gravação do arquivo)

           No curso informa que é criado um arquivo "authorized_keys" dentro da pasta .ssh, na máquina virtual.

           Porém, de qualquer forma, o acesso se torna possível pois temos a chave privada e podemos acessa-la digitando:

                ssh -i .vagrant/machines/default/virtualbox/private_key

           Usando autenticação em ambas como vimaos na aula sobre PuTTY.

           Para outras pessoas, inclusive desenvolvedores, se conectarem remotamente à máquina virtual, devem receber a chave privada.

    Gerando nossa própria chave privada:

       Fora da nossa máquina virtual...

       Podemos utilizar o PuTTY para criarmos a nossa chave ou, caso já tenhamos instalado em nossa máquina o SSH, podemos utilizar um meio bem mais fácil.

       Digitando o comando ssh e a tecla TAB (Algumas vezes) podemos ver os comandos do SSH que podem ser utilizados, um deles é o ssh-keygen.

       Então, adicionamos alguns parametros para criarmos nossa chave...

        $ ssh-keygen -t rsa

        Incluímos o caminho onde a chave será criada (De preferência a pasta raiz da máquina virtual) e inserimos um nome para esta chave.
            Obs: O nome da chave privada utilizada no curso foi "id_bionic64".

        O sistema irá pedir para criarmos uma senha de acesso para protegê-la, caso queira.

        Podemos verificar dentro da nossa pasta da máquina virtual agora que as duas chaves foram criadas.

        Agora iremos copiar nossa chave pública para dentro da máquina virtual...

        Acessamos novamente a máquina virtual com o comando $ vagrant ssh

        E após isso verificar a pasta Vagrant dentro do nosso Windows com:

         $ ls vagrant

        Copiamos a chave publica da pasta "vagrant" para a máquina virtual escrevendo:

            $ cp /vagrant/id_bionic.pub (Sendo possível visualiza-la novamente com $ ls)

        Agora iremos adiciona-la ao arquivo "authorized_keys"...

            $ cat id_bionic.pub >> .ssh/authorized_keys

        Finalize com $ exit retornando ao Windows.

        Desta vez executaremos o mesmo comando para acessar com chave privada, porém utilizando a nossa chave privada criada.

            $ ssh -i id_bionic vagrant@"IP da máquina virtual"

        Assim aprendemos como nos conectar remotamente à nossa máquina virtual baseada na chave pública/privada desde que as tenha associadas com a chave privada dentro da MV.

        $ vagrant list-commands = Exibe todos os comandos do Vagrant.

        Nesta aula, aprendemos que:

        - O comando vagrant ssh-config lista as configurações SSH que o comando vagrant ssh usará
        - O Vagrant gera automaticamente um par de chaves SSH
        - A chave pública fica na máquina virtual (guest), a chave privada fica no host
        - No arquivo .ssh/known_host, fica guardado o fingerprint de cada máquina com qual o SSH se conectou
        - Como criamos máquinas através do Vagrant com frequência, é preciso limpar esse arquivo .ssh/known_host (ou apagar) de tempos e tempos
        - Para gerar um par de chaves SSH, existe a ferramenta ssh-keygen
        - A chave pública deve ficar dentro do arquivo .ssh/authorized_keys da máquina virtual

   Questões:

        1 - Ao usar o comando vagrant ssh, é estabelecido uma conexão SSH com a máquina virtual. O que sabemos sobre essa conexão?

            Selecione 2 alternativas

            R1: É usada uma chave pública e privada para se autenticar
                 Alternativa correta! As chaves são automaticamente geradas e a chave pública é adicionada na máquina virtual.

            R2: É usado localhost para se conectar com a máquina virtual
                 Alternativa correta! O padrão é usar o localhost.


        2 - Qual é o comando para listar as configurações SSH?

            Obs: Você sempre pode verificar todos os comandos na documentação ou na linha de comando:

            vagrant list-commands

            Selecione uma alternativa

            R: vagrant ssh-config

               Alternativa correta! O comando apresenta várias informações úteis como host name, porta, usuário e localização da chave privada.


Aula 04 - Provisionando a máquina -------

   Comandos e teoria:

        Já vimos que, apesar do configurar nossas máquinas virtuais, o Vagrant não pode instalar endings como o MySQL por exemplo, adicionar chave extra etc.

        Porém podemos encontrar como automatizar muitas coisas na documentação do Vagrant na guia "Provisioning".

        Utilizaremos agora o "Shell Provisioner"

        Já vimos no curso de Linux que o Shell é onde podemos executar qualquer comando no Linux, executando assim qualquer tarefa, desde manipulação de pastas, arquivos e 
        usuários como a instalação de endings.

        Na final do conteúdo da guia "Provisioning" da documentação do Vagrant, encontramos o seguinte código de exemplo:

           Vagrant.configure("2") do |config|
               config.vm.provision "shell",
                   inline: "echo hello, World"
           end

        Podemos copiar e colar este código ao final do arquivo "VagrantFile" para ver o que acontece.

        Utilizamos o $ vagrant reload após colarmos o trecho de código.

        Um trecho informando "Machine Already Provisioned" irá aparecer.

        Execute o comando $ vagrant provision como solicitado.

        Após isto vemos o comando do Shell script sendo executado.

        Para vermos uma operação uma pouco mais sólida, alteramos a linha do código do Shell para:

            config.vm.provision "shell", inline: "echo Hello, World >> hello.txt"
            end

        Executamos mais uma vez o comando $ vagrant provision

        Assim o nosso "Hello, World" irá ser inserido no arquivo hello.txt dentro da máquina virtual.

        A linha que apresentava "Hello, World" desaparece.

        Agora podemos conferir se o arquivo foi criado acessando a máquina virtual:

            $ vagrant ssh

        Listando os arquivos internos:

            $ ls

        E verificando o conteúdo do arquivo hello.txt com:

            $ cat hello.txt

        Vemos que o trecho de código inserido no nosso "VagrantFile" foi executado dentro da máquina virtual.

        Entendemos então que podemos executar comandos Batch-Shell através destas configurações nos possibilitando fazer algumas coisas extra-Vagrant como instalação de programas, 
        por exemplo.

        Synced Folders

            Agora vamos aprender a transferir uma pasta para dentro da máquina virtual assim que ela for criada.

            No caso, é interessante já transferir a chave pública para dentro do arquivo "authorized_keys" dentro da máquina virtual.

            Assim como outros recursos do Vagrant, podemos aprender como se faz isso em sua documentação.

            Na guia Synced Folder podemos ver códigos de exemplo.

            Criamos uma pasta "configs" dentro da pasta da nossa máquina virtual e a transferimos para a máquina virtual inserindo dentro do arquivo VagrantFile:

                config.vm.synced_folder "./configs", "/configs"
               end

                Obs: O caminho na máquina virtual sempre deverá ser absoluto "/" (Sem ponto de abreviação de caminho)

            Assim iremos transferir para a raiz da máquina virtual nossa pasta configs com todo o seu conteúdo.

            Inserimos dentro desta pasta a chave pública.

            Como é importante, é interessante não deixarmos a pasta /vagrant (Que está dentro da máquina virtual) acessível a qualquer um.

            Realizamos esta configuração no VagrantFile da seguinte maneira:

                 config.vm.synced_folder ".", "/vagrant", disabled: true
                end

            Com isto feito, agora podemos automatizar a cópia da chave pública dentro da máquina virtual a partir da pasta copiada para o arquivo "authorized_keys".

                config.vm.provision "shell",
                        inline: "cat /configs/id_bionic.pub >> .ssh/authorized_keys"

            Agora podemos destruir e recriar a máquina virtual...

                $ vagrant destroy -f && vagrant up

            Entramos na máquina virtual para verificar se a chave pública foi inserida no arquivo "authorized_keys".

            Saímos da máquina virtual e deletamos o arquivo "known_hosts" dentro de c:\users\"usuário"\.ssh\known_hosts

            Refaça a conexão utilizando o comando:

                $ ssh -i id_bionic vagrant@"IP da máquina virtual"

        INSTALANDO MySQL ATRAVÉS DO SHELL

              Esta seguinte linha de código irá instalar o MySQL.
              O trecho de código é bem similiar aquele da cópia da chave pública.

              config.vm.provision "shell",
                      inline: "apt-get update && apt-get install -y mysql-server-5.7"

                        Obs: Estes comandos são executados automaticamente como sudo.

              Se observarmos a documentação do Vagrant, veremos que temos outra forma de fazer isto.

              Em "Shell Provisioner", dentro de "Provisioning" temos a variável $script, que é definida para ser adicionada e alterada no início do nosso arquivo "VagrantFile", 
              antes de (Vagrant.configure("2") do |config|). Também vemos no código seguinte como adicionar um usuário que pode acessar a máquina virtual a partir de qualquer host 
              com %.

                $script_mysql = <<-SCRIPT
                    apt-get update && \
                    apt-get install -y mysql-server-5.7 && \
                    mysql -e "create user 'phpuser'@'%' identified by 'pass';"
                SCRIPT

              Agora no fluxo das configurações do Vagrant, onde adicionavamos os comandos do linux para atualização de pacotes e instalação do MySQL, ficará assim:

                config.vm.provision "shell", inline: $script_mysql

              Após realizarmos o procedimento padrão de destruir e recriar a máquina:  $ vagrant destroy -f && vagrant up

              Testamos a conexão e o MySQL:

                    $ vagrant ssh

                    $ sudo mysql

              Verificamos se o usuário foi mesmo cadastrado:

                  $ select user from mysql.user
                    Obs: Não se esqueça de inserir o ponto e virgula e depois dar enter para ver o resultado da consulta.

              Estas configurações permitem que apenas esta máquina específica acesse o MySQL.

              Para que possamos automatizar o acesso devemos mexer no arquivo: mysqld.cnf

                cat /etc/mysql/mysql.conf.d/mysqld.cnf

                No trecho que possui o IP "bind-address = 127.0.0.1"

                O comando abaixo cria uma cópia do arquivo mysqld.cnf na nossa pasta "configs"

                    cat /etc/mysql/mysql.conf.d/mysqld.cnf > /configs/mysqld.cnf

              Abra o arquivo mysqld.conf que foi compartilhada na pasta configs que é comum a nossa máquina real, e edite a linha "bind-address" para 0.0.0.0, para que aceite a 
              conexão de outros IP's.

              Salvar e retornar para o arquivo "VagrantFile"

              Agora colocamos o comando no nosso "VagrantFile" para que o arquivo seja substituido nas configurações do MySQL na criação da máquina virtual.

                    config.vm.provision "shell",
                            inline: "cat /configs/mysqld.cnf > /etc/mysql/mysql.conf.d/mysqld.cnf"

              Devemos já reiniciar o MySQL para que o novo arquivo já tenha efeito em sua configuração. Isto também pode ser feita de forma automatizada no "VagrantFile"

                    config.vm.provision "shell",
                            inline: "service mysql restart"

              Pronto! Este é um exemplo básico de como provisionar para a máquina virtual um banco como MySQL, obviamente existem milhares de opções e adições a serem exploradas.

              O comando $ vagrant provision poderá apresentar erros, mas isto iremos trabalhando aos poucos e ajustando nosso provisionamento, aprimorando os scripts e ganhando 
              experiência.

              Se já atuamos como administradores podemos utilizar um recurso chamado "External Script" que está na documentação para adicionar no "VagrantFile" ou no próprio 
              repositório de códigos.


              Nesta aula, aprendemos que:

              - O provisionador mais simples é o Shell Provisioner
              - Provisionamento significa instalar e configurar tudo o que for necessário para rodar algum serviço ou aplicação

              - Para usar o Shell Provisionar, basta definir um script com os passos de instalação:
                      Vagrant.configure("2") do |config|
                      config.vm.provision "shell", path: "script.sh"
                      end

              - Os comandos do Shell Provisioner também podem ser usados de maneira inline ou remoto:
                      $script = <<-SCRIPT
                        echo Instalando MySQL
                      SCRIPT
                   ------->
                      Vagrant.configure("2") do |config|
                        config.vm.provision "shell", inline: $script
                   end
              Ou:

                      Vagrant.configure("2") do |config|
                        config.vm.provision "shell", path: "https://seu-servidor/script.sh"
                   end

              - O Vagrant automaticamente compartilha uma pasta entre o host e o guest (Synced Folder)
              - Por padrão, é compartilhada a pasta onde se encontra o Vagrantfile
              - Na máquina guest, podemos acessar a pasta pelo caminho /vagrant

              - A pasta compartilhada pode ser reconfigurada no Vagrantfile:
                    config.vm.synced_folder "src/", "/public"

   Questões:

           1 - O que significa provisionar?

              Selecione uma alternativa

              R: Significa providenciar tudo que for preciso para executar um serviço

              Alternativa correta! Provisionar significa fornecer a rede, CPU, memória, espaço, mas também o sistema operacional e pacotes, além da implantação em si. Tudo o que 
              for preciso para rodar/executar o serviço. Melhor ainda, fica automatizado e pode ser repetido a qualquer momento.


           2 - Qual é o mapeamento padrão da pasta compartilhada?

              Selecione uma alternativa

              R: No host é compartilhado a pasta que possui o Vagrantfile. No guest essa pasta é chamada de /vagrant.

              Alternativa correta! Logada a máquina virtual, podemos acessar o host pela pasta /vagrant. Por padrão, é compartilhado todo diretório onde se encontra o Vagrantfile.


           3 - Os provisionadores são chamados sempre:

               Obs: Se tiver com dúvida, verifique a documentação.

               Selecione uma alternativa

               R: . quando executamos o comando vagrant provision.

               Alternativa correta! Esse comando pede explicitamente a execução de todos os provisionadores configurados.


Aula 05 - Conhecendo o Puppet -------

        AMBIENTE MULTI-MACHINE

            Podemos configurar várias máquinas virtuais dentro de um único arquivo "VagrantFile"

                Obs: Mais detalhes e modelos de código na documentação do Vagrant no tópico "Multi-Machine"

            No exemplo a seguir veremos a criação de duas máquinas virtuais uma para o mysqldb e uma para phpweb

                    config.vm.define "mysqldb" do |mysqldb|

                        mysqldb.vm.network "public_network", ip: "192.168.1.14"

                        mysqldb.vm.synced_folder "./configs", "/configs"
                        mysqldb.vm.synced_folder ".", "/vagrant", disabled: true

                        mysqldb.vm.provision "shell", inline: "cat /configs/id_bionic64.pub >> .ssh/authorized_keys"
                        mysqldb.vm.provision "shell", inline: $script_mysql
                        mysqldb.vm.provision "shell", inline: "cat /configs/mysqld.cnf > /etc/mysql/mysql.conf.d/mysqld.cnf"
                        mysqldb.vm.provision "shell", inline: "service mysql restart"

                      end

            Repare que onde estava config (Se referindo a máquina default do Vagrant) agora temos mysqldb, de forma a encapsular nossa máquina virtual não subindo mais a antiga.

            Para testarmos uma nova máquina adicionaremos ao mesmo arquivo após o parâmetro "end" da máquina virtual anterior, um trecho de código para criar a máquina "phpweb"

                    config.vm.define "phpweb" do |phpweb|
                            phpweb.vm.network "forwarded_port", guest:80, host:8089
                            phpweb.vm.network "public_network", ip: "192.168.1.25"
                      end

            Tiramos o forwarded port do exemplo anterior e deixamos esta configuração na máquina virtual phpweb

                Obs: Temos que destruir a máquina default, antes de mudar toda a configuração do "VagrantFile" pois ela continuará existindo no VirtualBox e por consequência, utilizando 
                todas as portas configuradas por nós anteriormente.

                Obs2: É importante saber que, para utilizar os comandos do vagrant, como $ vagrant status, $ vagrant halt ou $ vagrant destroy -f em uma determinada máquina, precisamos ter seu código no VagrantFile,
                    se não ela ficará no limbo, existindo sem a possibilidade de ser manipulada.

            A partir do momento que foram criadas mais de uma máquina no mesmo arquivo do vagrant, podemos utilizar os comandos de forma independente...

                Ex.:

                        $ vagrant status "máquina 1"

                        $ vagrant destroy -f "máquina 2"

                        Assim como conexão e desligamento etc...

                        $ vagrant ssh "máquina 1"

                        $ vagrant halt "máquina 2"

                        E assim por diante, todos os outros comandos trabalham neste padrão...

            Depois de utilizar o comando $ vagrant up para subir as duas máquinas, utilize o comando $ vagrant ssh-config.

                Repare que são usadas portas diferentes para cada uma das máquinas.

                $ vagrant validate = Na raiz do projeto, valida o arquivo VagrantFile.

   PUPPET

        Na parte "Provisioning" da documentação do Vagrant, temos várias ferramentas para nos ajudar a configurar nossas máquinas virtuais.

        PUPPET APPLY PROVISIONER

            Nesta página podemos encontrar modelos básicos de configurações, que nos ajudam muito com o Puppet:
            http://www.digitalocean.com/community/tutorials/getting-started-with-puppet-code-manifests-and-modules

            Para utilizar esta aplicação criamos "manifests files" em um novo diretório que podemos deixar em comum com nossa máquina virtual como o "configs", porém esta chamamos de "manifest".
                Obs: Nas nossas atividades deixamos a pasta manifest dentro de configs, pois ela já estava sendo criada automaticamente na máquina virtual em nosso "VagrantFile".

            Os arquivos para testes que criamos são: phpweb.pp e index.pp

             Este conteúdo a seguir ficará dentro do arquivo phpweb.pp

                    # execute 'apt-get update'
                    exec { 'apt-update':
                        command => '/usr/bin/apt-get update'
                    }

                    package { ['php7.2' ,'php7.2-mysql'] :
                        require => Exec['apt-update'],
                        ensure => installed,
                    }

                    exec { 'run-php7':
                        require => Package['php7.2'],
                        command => '/usr/bin/php -S 192.168.1.25:8888 -t /vagrant/src &'
                    }

             Para testarmos temos que conectar à nossa máquina virtual phpweb

                $ vagrant ssh phpweb

             Para verificar este novo arquivo que criamos, basta seguirmos o caminha da pasta compartilhada.

                $ ls /vagrant/configs/manifest/

             Podemos executar o puppet para ver se ele existe

                $ puppet

             No caso da nossa aula ele ainda não foi instalado na nossa máquina virtual, por isso temos que executar um update e depois a instalação do mesmo.

                $ sudo apt-get update && sudo apt-get install -y puppet

             Limpe a tela e ative-o com:

                $ sudo puppet apply /vagrant/configs/manifest/phpweb.pp

        INTEGRANDO O PUPPET COM O VAGRANT

            Podemos no "VagrantFile" adicionar a instalação do Puppet através do Shell, dentro da máquina virtual phpweb. Também adicionamos o arquivo de configuração (Manifest) 
            phpweb.pp.

                phpweb.vm.provision "shell",
                            inline: "apt-get update && apt-get install -y puppet"

                        phpweb.vm.provision "puppet" do |puppet|
                            puppet.manifests_path = "./configs/manifests"
                            puppet.manifest_file = "phpweb.pp"
                        end
                    end
                end

            Alteramos as portas no phpweb.pp, além do ip que configuramos no arquivo mysqld.cnf, além de referenciar a pasta onde está o index.php (src), para testar o MySQL

                    exec { 'run-php7':
                        require => Pachage['php7.2'],
                        command => '/usr/bin/php -S 0.0.0.0:8888 -t /vagrant/src &'

            Neste momento temos que destruir e recriar nossa máquina virtual phpweb

                $ vagrant destroy -f phpweb && vagrant up phpweb

            Verificamos se a máquina está rodando novamente

                $ vagrant ssh phpweb

            Seguido de

                $ netstat -tln

                    Para ver se as portas estão com conexão ativa

            E depois

                $ ps aux | grep php

                    para encontrar o processo

            Agora editaremos o arquivo index.pp criado na pasta src, devemos inserir o seguinte conteúdo a principio

                <?php
                    echo "Funcionou!!!"
                ?>

                Devemos abrir o navegador e testar a porta 192.168.1.15:8888

                    Para ver se funcionou

            Para que possamos integrar/testar também o MySQL da nossa outra máquina criada com o arquivo index.php, vamos adicionar uma lógica básica onde realizamos um teste 
            simples de conexão.

                <?php
                    echo "Testando conexao <br /> <br />";
                    $servername = "192.168.1.24";
                    $username = "phpuser";
                    $password = "pass";

                    // Create connection
                    $conn = new mysqli($servername, $username, $password);

                    // Check connection
                    if ($conn->connect_error) {
                        die("Conexão falhou: " . $conn->connect_error);
                    }
                    echo "Conectado com sucesso";
                ?>

        Assim a integração com as máquinas (phpweb e mysqldb) está concluída.

        Obs: Este foi um teste simples com o Puppet, temos que fazer um curso para realmente poder trabalhar com a ferramenta.

        Obs2: Para não esquecer, a extensão ".pp" se refere somente ao puppet, pois são seus "Manifests Files".

        Obs3: Na documentação do Vagrant encontramos todas as variáveis e comandos necessários para utilizar os "provisionadores" como o puppet.
            No caso do Puppet basta, além da declaração de sua referência no arquivo "VagrantFile", definir seu caminho (manifest_path) e o arquivo de configuração (manifest_file)

        Obs4: Temos que sempre prestar atenção nas camadas, nos parâmetros e variáveis que a documentação nos ensina a usar, principalmente a abertura do arquivo "VagrantFile", 
            suas "Máquinas virtuais" e suas subconfigurações.


        Nesta aula, aprendemos que:

        - No mesmo Vagrantfile, podemos configurar várias máquinas, separando as configurações (Multi-Machine)
        - O Puppet é uma ferramenta popular para provisionar uma máquina
        - Provisionamento significa instalar e configurar tudo o que for necessário para rodar algum serviço ou aplicação
        - Com Puppet, podemos definir os passos de instalação de mais alto nível, facilitando a manutenção
        - Os passos de instalação são configurados em um arquivo manifest, com a extensão .pp
        - Para rodar o Puppet, é preciso instalar um cliente na máquina virtual
        - O Vagrant integra e consegue chamar o Puppet a partir do comando vagrant provision
        - Ao rodar o comando vagrant up pela primeira vez, ele também roda o provisionamento

        - Para configurar o Puppet dentro do Vagrantfile, basta usar:
                config.vm.provision "puppet" do |puppet|
                  puppet.manifests_path = "manifests"
                  puppet.manifest_file = "wep.pp"
                end


   Questões:

         1 - Veja o Vagrantfile abaixo:

            Vagrant.configure("2") do |config|

              config.vm.define "phpweb" do |php_config|
                php_config.vm.box = "apache"
              end

              config.vm.define "mysqldb" do |mysql_config|
                mysql_config.vm.box = "ubuntu/bionic64"
              end
            end

            Quais comandos abaixo sobem, de uma vez só, as duas máquinas configuradas acima?

            Selecione 2 alternativas

            R1: $ vagrant up

               Alternativa correta! Ao usar vagrant up, subimos todas as máquinas, na ordem da declaração no Vagrantfile.

            R2: $ vagrant up phpweb mysqldb

                Alternativa correta! No entanto, o comando sobe primeiro a máquina phpweb e depois o mysqldb (mesmo se forem declaradas em uma outra ordem no Vagrantfile).


        2 - Você está ajudando uma outra equipe de desenvolvimento, que também usa Vagrant. Ao executar o comando vagrant status, você recebe a seguinte saída:

            $vagrant status
            Current machine states:
            testing                  poweroff (virtualbox)
            homologacao              not created (virtualbox)
            production               running (virtualbox)
            Sabendo disso, quais afirmações abaixo são verdadeiras?

            Selecione 2 alternativas

            R1: Duas máquinas já foram importadas

                Alternativa correta! As máquinas testing e production já foram importadas e rodaram pelo menos uma vez. A máquina homologacao ainda não foi importada e criada.

            R2: Para parar a máquina production, podemos usar o comando vagrant halt production

                Alternativa correta! O comando vagrant halt desliga a máquina virtual e ela assume o status poweroff.


        3 - O foco do curso é o Vagrant, mas vimos também alguns detalhes sobre o Puppet. O que podemos dizer sobre o Puppet?

            Selecione 2 alternativas

            R1: É uma ferramenta relacionada ao IaC (Infrastructure as Code)

                Alternativa correta! Através do Puppet, definimos a configuração da máquina em um script, como se tudo fosse um código.

            R2: Puppet precisa de um agent instalado, como na máquina guest

                Alternativa correta! Para aplicar o script de configuração (*.pp), é preciso ter instalado um puppet client na máquina guest.


Aula 06 - Usando o Ansible -------

    Comandos e Teoria

        Integraremos mais um provisionador, o Ansible.

            Iniciamos o modulo utilizando Shell Provisioner para enviar comandos para a máquina virtual, como foi no caso em que instalamos o MySQL.
            Porém, ficou claro que existem Provisionadores mais eficazes.

            Com isso vimos o Puppet, que através de um arquivo que chamaos de manifest, podemos provisionar a máquina virtual, o problema é que está é uma ferramenta que precisa 
            estar instalada no guest.
            Ex.: Queriamos somente o PHP instalado, mas como estavamos utilizando o Puppet para fazer isso, tivemos que utilizar o VagrantFile para realizar esta instalação.

            Já no caso do Ansible, utilizamos ele instalando apenas no host, assim como o Vagrant, e definimos todo o processo em um documento que chamamos de playbook.yml análogo 
            aos arquivo do puppet (.pp) o qual envia os comandos para a máquina virtual.

            Além desta distinção, precisamos ter o Python instalado nesta máquina, porém é uma ferramenta comum em sistemas linux, bem provávelmente não precisamos instala-la.

            O problema na verdade é para usuários Windows, pois o Ansible roda somente em Linux ou Mac, diferente do Vagrant que é habilitado para todos.

            Logo, precisamos criar uma máquina virtual para executar o Ansible e reconfigurar o MySQL, se tiver uma WSL.

        Instalação do Ansible:

            Garantimos que nenhuma máquina esteja rodando utilizando o comando:

                $ vagrant status

            Criamos uma nova máquina virtual "mysqlserver" e utilizaremos uma máquina com o Ansible com IP diferente.

            Como visto antes, não temos como utilizar o Ansible no Windows então precisamos utilizar uma máquina com linux, pode ser outra máquina virtual criada com o Vagrant.

                Obs: No momento que fiz o curso estava utilizando minha máquina do WSL com Kali.

            Abaixo está o código de como ficou a parte do mysqlserver e do ansible no "VagrantFile"

               config.vm.define "mysqlserver" do |mysqlserver|
                       mysqlserver.vm.network "public_network", ip: "192.168.1.22"
                   end

                   config.vm.define "ansible" do |ansible|
                       ansible.vm.network "public_network", ip: "192.168.1.26"
                       ansible.vm.provision "shell",
                           inline: "apt-get update && \
                                    apt-get install -y software-properties-common && \
                                    apt-add-repository --yes --update ppa:ansible/ansible && \
                                    apt-get install ansible"
                   end
               end

            Verificamos se nosso código é funcional com o comando:

                $ vagrant validate

            Para visualizar as quatro máquinas virtuais

                $ vagrant status

            E para que ativemos/criemos apenas a máquina que possui o ansible

                $ vagrant up ansible

            Agora adicionaremos a chave pública através do "VagrantFile", criada anteriormente, e adicionamos a nossa maquina virtual mysqlserver

                mysqlserver.vm.provision "shell",
                            inline: "cat /vagrant/configs/id_bionic.pub >> .ssh/authorized_keys"

            Agora subimos nossa maquina virtual mysqlserver:

                $ vagrant up mysqlserver

            Verificamos a conexão com:

                $ vagrant ssh mysqlserver

            Adicionamos a chave privada à máquina com Ansible e mudamos a permissão para que o mesmo possa acessar a máquina mysqlserver:

               config.vm.define "ansible" do |ansible|
                   ansible.vm.network "public_network", ip: "192.168.1.17"

                   ansible.vm.provision "shell",
                       inline: "cp /vagrant/id_bionic64 >> /home/vagrant && \
                               chmod 600 /home/vagrant/id_bionic64"

            Obs: Sobre >> e > 
                echo "teste" > /path/arquivo : Vai sobrescrever todo arquivo pela palavra teste

                echo "teste" >> /path/arquivo : Vai acrescentar no final do arquivo a palavra teste

            Testamos o código do "VagrantFile" para o ansible:

                $ vagrant provision ansible

            Tambem testamos sua conexao:

                $ vagrant ssh ansible

            Agora temos preparada a maquina do ansible e a maquina com o banco de dados que ira servi-lo.

            Agora iremos executar o "playbook.yml" para fazer as configurações necessárias

        TESTANDO O PLAYBOOK

            Devemos criar uma nova pasta ansible, onde estarão os arquivos de Hosts que define as máquinas que serão configuradas com uma lista de IP's e algumas configurações de 
            usuário. Carrega também configurações de usuário, conexão, chave privada, permissões e padrão Python.

            ------>
                [mysqlserver]
                192.168.1.22

                [mysqlserver:vars]
                ansible_user=vagrant
                ansible_ssh_private_key_file=/home/vagrant/id_bionic
                ansible_python_interpreter=/usr/bin/python3
                ansible_ssh-commom_args='-o StrictHostKeyChecking=no'
            <------

            Agora que temos as configurações da máquina e os padrões de configurações da mesma, vamos criar o arquivo playbook.yml com as tasks a serem rodadas na máquina virtual.

            ------>
                - hosts: all
                    handlers:
                        - name: restart mysql
                            service:
                                name: mysql
                                state: restarted
                            become: yes

                    tasks:
                        - name: 'Instalar MySQL Server'
                            apt:
                                update_cache: yes
                                cache_valid_time: 3600 #1 hora
                                name: ["mysql-server-5.7", "python3-mysqldb"]
                                state: latest
                            become: yes

                        - name: 'Criar usuario no MySQL'
                            mysql_user:
                                login_user: root
                                name: phpuser
                                password: pass
                                priv: '*.*:ALL'
                                host: '%'
                                state: present
                            become: yes

                        - name: 'Copiar arquivo mysqld.cnf'
                            copy:
                                src: /vagrant/configs/mysqld.cnf
                                dest: /etc/mysql/mysql.conf.d/mysqld.cnf
                                owner: root
                                group: root
                                mode: 0644
                            become: yes
                            notify:
                                - restart mysql
            <------

            Não vamos nos aprofundar em ansible neste curso, apenas realizaremos a integração do mesmo com o Vagrant.

            Para testar nossos arquivos hosts e playbook.yml, nos conectamos a máquina virtual com ansible e realizamos o comando:

                $ ansible-playbook -i /vagrant/configs/ansible/hosts /vagrant/configs/ansible/playbook.yml

                se quisermos colocar em duas linhas para não oculpar tanto espasso com o shell

                $ ansible-playbook -i /vagrant/configs/ansible/hosts >
                    /vagrant/configs/ansible/playbook.yml

                Obs: Lembrando sempre que todo caminho depende de onde nossos arquivos estão.

                Obs2: Devemos sempre nos atentar aos erros. Erros de permissões à determinadas pastas ou arquivos devem ser sanados com cuidado, pois determinados niveis de acesso 
                não podem ser concedidos a qualquer usuário.

            No caso do curso podemos mudar o proprietário do arquivo/diretório com o comando chown:

                $ sudo chown vagrant:vagrant id_bionic

            Já num caso real temos que estudar os níveis de permissão que podem ser concedidos em determinado diretório.

                Lembrando sempre do comando $ ls -la para que possamos ver todas as permissões do arquivo/diretório.

            Mais uma vez testamos o comando

                $ ansible-playbook -i /vagrant/configs/ansible/hosts /vagrant/configs/ansible/playbook.yml

            Caso antes não tenha dado certo.

            Um exemplo de caminhos diferentes para o arquivo são os testes feitos na minha máquina Kali do WSL.

                $ ansible-playbook -i /home/nezzonarcizo/vagrant/configs/ansible/hosts /home/nezzonarcizo/vagrant/configs/ansible/playbook.yml

                Obs: No meu caso em particular não houve erro de permissões, apenas um probleminha com o Python

                Obs2: A identação é importantissima nos arquivos .yml, sua identação tem que estar exata, respeitando sempre os dois espaços da margem ou o bloco de código no qual 
                o parâmetro esta inserido.

                Obs3: O parâmetro "-i" significa inventario

                    Ou seja, passamos as configurações do inventário "-i" "hosts" para o arquivo de "tasks" "playbook.yml"


        INTEGRAÇÃO DO ANSIBLE COM O VAGRANT

            Agora devemos verificar com $ vagrant status que as máquinas virtuais mysqlserver e ansible estão rodando.

            Devemos subir também a máquina phpweb

                $ vagrant up phpweb

            Devemos mudar o $servername para a porta 192.168.1.16 do index.php para testar e ver se o banco criado com o playbook.yml do Ansible está realmente funcionando

             Obs: Lembrando que as portas para testar o phpweb no navegador são: 192.168.1.15 e localhost:8888

             No caso, se estivermos utilizando Windows devemos adicionar o código abaixo para rodar de forma automática o Ansible

                ansible.vm.provision "shell",
                            inline: "ansible-playbook -i /vagrant/configs/ansible/hosts \
                                 /vagrant/configs/ansible/playbook.yml"

             Após estas alterações devemos destruir todas as máquinas virtuais.

                $ vagrant destroy -f

             E comentar todas as linhas do código do mysqldb que não está sendo mais usado.

             Testamos para ver se tudo está funcionando novamente com:

                $ vagrant up

             - Já vi que o ansible envia comandos para máquinas criadas pelo vagrant.

             - Que o Vagrant também pode utilizar o ansible instalado em uma máquina criada por ele.

             - Uma coisa que terei que estudar mais a frente é se tem como o Vagrant mandar comandos através do provision para uma máquina que não esteja no Hypervisor.

        Nesta aula, aprendemos que:

        - O Ansible, assim como o Puppet, é uma ferramenta para provisionar uma máquina
        - O Ansible envia comandos SSH para a máquina a ser configurada, e não precisa de um cliente instalado (apenas o Python)
        - Os passos de instalação são configurados de alto nível, dentro de um playbook.
        - O arquivo de inventário (hosts) define os alvos da instalação

        - O Vagrant integra o Ansible e tem uma configuração dedicada:
           config.vm.provision "ansible" do |ansible|
                ansible.inventory_path = "hosts"
                ansible.playbook = "playbook.yml"
            end

    Questões:

        1 - Quais foram as principais diferenças entre Puppet e Ansible mencionadas no vídeo?

            Selecione 2 alternativas

            R1: O Ansible não precisa de um cliente na máquina guest, o Puppet sim.

                Alternativa correta! O Ansible não possui nenhum cliente na máquina a configurar, no entanto precisa de Python pré-instalado.

            R2: O Ansible empurra as configurações do host para o guest, o Puppet "puxa" as configurações do host para o guest.

                Alternativa correta! Por isso o Ansible não precisa do cliente instalado, pois empurra os comandos para o guest, através do SSH.


        2 - Quais são os pré-requisitos para rodar o Ansible?

            Selecione 2 alternativas

            R1: O host precisa ser um sistema *NIX (algum sistema Unix)

                Alternativa correta! Infelizmente o Ansible não funciona no Windows. Por isso criamos uma máquina virtual com Ubuntu, só para instalar e rodar o Ansible.

            R2: O SSH deve funcionar entre o host e o guest

                Alternativa correta! O Ansible envia comandos SSH do host para o guest.


        3 - Vimos durante a aula dois arquivos específicos do Ansible (existem mais), o arquivo playbook.yml e hosts.

            Qual é o papel do arquivo hosts?

            Selecione uma alternativa

            R:  É o inventário que define quais máquinas queremos provisionar

                Alternativa correta! O arquivo hosts possui os endereços das máquinas onde queremos aplicar o provisionamento. Podemos definir grupos de máquinas e definir 
                detalhes da conexão SSH, como a chave ou usuário.


        4 - Novamente, você foi chamado para ajudar uma equipe que usa o Vagrant, mas agora também tem o Ansible envolvido. Você encontrou o Vagrantfile abaixo:

            Vagrant.configure("2") do |config|

              config.vm.box = "ubuntu/bionic64"

              config.vm.network "forwarded_port", guest: 80, host: 8080

              config.vm.provision "ansible" do |ansible|
                ansible.inventory_path = "./hosts"
                ansible.playbook = "./playbook.yml"
              end
            end
            O que você sabe sobre a máquina host?

            Selecione uma alternativa

            R: O Ansible deve estar instalado na mesma máquina do Vagrant, pois usamos o provisioner do Vagrant para chamar o Ansible

               Alternativa correta! O Vagrant vai tentar chamar o Ansible na própria máquina host.


Aula 07 - Configurações do Provedor -------

    Comandos e Teoria:

        CONFIGURAÇÕES DO PROVIDER:

            Com o VagrantFile criamos algumas máquinas virtuais e se olharmos na interface do Oracle Virtual Box vemos que cada uma delas usam recursos do sistema (Memória e CPU) 
            com definições padrões na hora da criação.

                Obs: No momento do curso, as máquinas estão sendo criadas por padrão com 1024 de memória e 2 cpu's.

            Se olharmos a documentação do Vagrant poderemos ver na parte "Configuration" do "Provider" "Virtual Box" que é possível definir os recurso de nossa máquina que serão 
            utilizados na criação de cada máquina virtual.

            A documentação nos da o seguinte trecho de código para ser inserido no nosso VagrantFile:

                Vagrant.configure ("2") do |config|
                    config.vm.box = "ubuntu/bionic64"

                    config.vm.provider "virtualbox" do |vb|
                    vb.memory = 512
                    vb.cpus = 1
                end

            Executando o comando $ vagrant up agora com este trecho de código, poderemos ver na interface do Oracle Virtual Box que nossas máquinas foram criadas com os recursos 
            definidos por nós.

            Estas configurações podem ser setadas de forma individual para cada máquina virtual, inserindo dentro do trecho de código no VagrantFile da máquina desejada.

                Como exemplo, definimos apenas que a máquina "phpweb" volte as configurações padrão, deixando-a com 1024 de memória e 2 cpu's:

                    config.vm.define "phpweb" do |phpweb|
                            phpweb.vm.network "forwarded_port", guest: 8888, host: 8888
                            phpweb.vm.network "public_network", ip: "192.168.1.25"

                            phpweb.vm.provider "virtualbox" do |vb|
                                vb.memory = 1024
                                vb.cpus = 2
                                vb.name = "ubuntu_bionic_php7"
                            end

                Em seguida podemos utilizar o comando:

                    $ vagrant reload phpweb

                E veremos as configurações serem setadas apenas nesta máquina.


        VAGRANT BOX E GLOBAL STATUS:

            info: Podemos encontrar os "box" baixados com os sistemas operacionais no diretório raiz do usuário em c:\ na pasta .vagrant.d\boxes

            infor: Podemos ativar a interface gráfica da mesma forma que alteramos os recursos da máquina virtual com o trecho de código:

                config.vm.provider "virtualbox" do |v|
                  v.gui = true
                end

            Obs: Lembrando sempre que se digitarmos o comando $ vagrant veremos todos os outros comandos disponíveis.

            Devemos observar que o comando $ vagrant status só funciona em ambientes que temos o "VagrantFile"

            Porém se utilizarmos este comando em lugares que não temos o "VagrantFile" ele nos dará a dica de que outro comando poderá nos mostrar as máquinas ativas no nosso 
            sistema, o:

                $ vagrant global-status

            Este comando nos mostrará todas as máquinas existentes no nosso computador.

            O Vagrant dispõe de comandos que podem ser utilizados a partir de qualquer diretório desde que passemos os parâmetros solicitados.

            O comando:

                $ vagrant global-status --prune

                Exibe somente as máquinas virtuais com configurações devidamente validadas.

            Assim teremos o ID de cada máquina virtual no nosso computador, então:

                $ vagrant halt "id"

                Pode parar a máquina virtual com o id informado.

            Podemos criar as máquinas virtuais cada uma com seu sistema operacional, aprendemos no curso como criar uma máquina virtual mais leve, utilizando o S.O centOS 7.

            Acessamos o site do Vagrant Cloud e copiamos e colamos o código do "box" do centOS para que o mesmo fosse baixado.

                Abaixo uma configuração de máquina cache para php, com um sistema operacional mais leve e utilizando menos recurso do que o padrão:

                config.vm.define "memcached" do |memcached|
                    memcached.vm.box = "centos/7"
                    memcached.vm.provider "virtualbox" do |vb|
                        vb.name = "centos7_memcached"
                        vb.memory = 512
                        vb.cpus = 1

                end

            Na mesma pasta do bionic64 (Pois estamos utilizando seu VagrantFile) executamos o comando:

                $ vagrant status

                Vemos que a máquina está lá porém não criada.

                Se utilizarmos o comando:

                    $ vagrant global-status

                    Veremos que ela não é exibida pois ainda não à subimos.

                    $ vagrant up memcached

                        Para subir a máquina virtual.

            $ vagrant box = Para vermos quais comandos para os "box's" podemos utilizar.

            $ vagrant box list = Para vermos a nossa lista de "box".

            $ vagrant box prune = Para remover os box desatualizados e/ou duplicados.

            $ vagrant box remove "nome do box" = Para remover um box específico.

    Nesta aula, aprendemos que:

    - No Vagrantfile, podemos definir configurações específicas do provedor (hypervisor)
    - As configurações são referente à memória, CPU, rede ou interface gráfica, entre outras opções
    - Para listar todos as boxes baixadas, use o comando: $ vagrant box list
    - Para remover as boxes desatualizadas: $ vagrant box prune ou $ vagrant box remove <nome>
    - Para listar todas as máquinas que foram criadas no host, use: $ vagrant global-status --prune
    - Através do ID da máquina, podemos controlar a máquina virtual fora da pasta do projeto, por exemplo: $ vagrant destroy -f <ID-da-VM>


    Questões:

        1 - Com qual comando você pode ver todas as máquinas configuradas no host, garantindo que entradas inválidas não apareçam?

            Selecione uma alternativa

            R: vagrant global-status --prune

               Alternativa correta! O comando global-status mostra todas as máquinas configuradas no host, e a flag --prune garante que entradas desatualizadas serão removidas.


        2 - Vimos os comandos do Vagrant para controlar uma máquina virtual, como vagrant up ou vagrant provision.

            Em configurações Multi-Machine, é possível ser mais específico e usar o nome da configuração/máquina, por exemplo vagrant up phpweb.

            Nesses comandos, em lugar do nome, podemos usar também:

            Selecione uma alternativa

            R: O ID da máquina

               Alternativa correta! Você pode passar o nome ou o ID. O importante é que podemos executar o comando a partir de qualquer pasta, usando o ID da máquina.

               Funciona a partir de qualquer diretório (Vemos os ID's das máquinas com $ vagrant global-status), por exemplo:

               vagrant destroy -f <ID>


Aula 08 - Virtualização vs Container -------

    Comandos  e Teoria:

        Containers são mais leves do que virtualização de máquinas virtuais para utilizar cada aplicativo.

        Ao contrário do recurso Hypervisor que o Vagrant utiliza, o Docker utiliza o recurso Container Engine, o qual depende do Linux.

        Não temos simulações de outros sistemas operacionais para rodar as ferramentas.

        Ou seja, teremos uma biblioteca de dados carregada no sistema operacional, por isso não é preciso que os programas possuam sua própria máquina, pois se conecta 
        diretamente à fonte através dos containers, tornando-os mais leves e rápidos.

        Esta técnica se tornou popular por ser eficiente e prática.

            Obs: Mas sempre depende do padrão e necessidade da empresa, não precisamos oferecer uma grande solução para problemas pequenos.

            Existem poucas versões do Windows que comportam os containers automaticamente, tornando pouco acessível.

                Nesta página https://docs.docker.com/docker-for-windows/install/, encontramos o link para baixar o Docker Hub, porém ele informa que há a necessidade de ter 
                instalado o Hyper-V, o qual é compativel com todas as versões do Windows.

        Criando um ambiente com o Vagrant para provisionar o Docker no Windows.

            config.vm.define "dockerhost" do |dockerhost|
                    dockerhost.vm.provider "virtualbox" do |vb|
                        vb.memory = 512
                        vb.cpus = 1
                        vb.name = "ubuntu_dockerhost"
                    end

                    dockerhost.vm.provision "shell",
                        inline: "apt-get uptade && apt-get install -y docker.io"
                end

            $ vagrant up dockerhost

            Para testarmos...

                $ vagrant ssh dockerhost

                $ sudo docker --version

            Ou execute o comando direto logo após a criação da máquina virtual dockerhost...

                $ vagrant up dockerhost && vagrant ssh dockerhost

            Desta forma, caso precisemos, já temos um ambiente de estudos criado para trabalharmos.

            No Vagrant Cloud podemos encontrar um box com as configurações específicas (Já com o Docker instalado) sem que precisemos fazer tudo do zero.

            Se fizermos um teste tentando subir uma imagem específica no Docker...

                $ sudo docker run hello-world

                Veremos que a saída nos mostra que o programa não identificou este pacote no host e tenta baixar da fonte.

        Nesta aula, aprendemos que:

        - O Docker é uma tecnologia para criar, rodar e administrar containers, baseado no Linux
        - Containers virtualizam o sistema operacional
        - Máquinas virtuais virtualizam o hardware
        - Containers são mais leves do que máquinas virtuais
        - Ambos, containers e máquinas virtuais, servem para rodar e isolar processos e aplicações


    Questões:

        1 - Com a virtualização através dos Hypervisors, podemos diminuir os recursos físicos na empresa. Podemos aproveitar melhor cada hardware, instalando vários sistemas 
            operacionais na mesma infraestrutura, reduzindo assim os custos de luz e rede, já que não teremos mais vários servidores físicos, e teremos menos ociosidade do 
            hardware.

            Mas as máquinas virtuais também possuem problemas e desvantagens. Quais identificamos no último vídeo?

            Selecione 2 alternativas

            R1: Cada máquina virtual possui o seu sistema operacional, que terá o seu custo de hardware para manter suas funcionalidades

                Alternativa correta! Por exemplo, para isolar o MySQL, teremos que carregar um sistema operacional inteiro, que vai ocupar o hardware do host.

            R2: É impossível aproveitar alguma biblioteca do sistema operacional do host

                Alternativa correta! O objetivo do Hypervisor é justamente simular uma infraestrutura e isolar o sistema operacional do host.


        2 - Vimos as diferenças entre containers e virtualização, mas eles também têm algo em comum. O quê?

            Selecione 2 alternativas

            R1: Ambos servem para isolar um processo ou aplicação

                Alternativa correta! Ambos possibilitam rodar uma aplicação ou processo de maneira isolada, sem "sujar" ou ter a influência do sistema do host por baixo dos panos.

            R2: Ambos fazem parte do mundo DevOps

                Alternativa correta! A virtualização foi um passo fundamental e importante para facilitar a criação do recursos (diminuindo o tempo e gasto, aumentando 
                confiabilidade, etc) e os containers agilizam ainda mais o deploy de aplicações. Ambos são pilares do mundo DevOps.

